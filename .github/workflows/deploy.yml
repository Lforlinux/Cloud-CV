# Cloud CV - CI/CD Pipeline
# Automated deployment for SRE/DevOps Engineer Portfolio

name: Deploy Cloud CV

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  TERRAFORM_VERSION: 1.6.0
  DOCKER_BUILDKIT: 1

jobs:
  # Code quality and security checks
  quality-checks:
    name: Quality & Security Checks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: |
          npm install -g @lhci/cli
          npm install -g lighthouse

      - name: Run Lighthouse CI
        run: |
          lhci autorun
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}

      - name: Security scan with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Build and test Docker image
  build-and-test:
    name: Build & Test Docker Image
    runs-on: ubuntu-latest
    needs: quality-checks
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, test, and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/cloud-cv:${{ github.sha }}
            ${{ steps.login-ecr.outputs.registry }}/cloud-cv:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: Run container security scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.login-ecr.outputs.registry }}/cloud-cv:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-image-results.sarif'

      - name: Upload Trivy image scan results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-image-results.sarif'

  # Deploy infrastructure with Terraform
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [quality-checks, build-and-test]
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Format Check
        run: terraform fmt -check
        working-directory: ./infra/terraform

      - name: Terraform Init
        run: terraform init
        working-directory: ./infra/terraform

      - name: Terraform Validate
        run: terraform validate
        working-directory: ./infra/terraform

      - name: Terraform Plan
        run: terraform plan -out=tfplan
        working-directory: ./infra/terraform

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan
        working-directory: ./infra/terraform

      - name: Get Terraform outputs
        id: terraform-outputs
        run: |
          echo "bucket_name=$(terraform output -raw bucket_name)" >> $GITHUB_OUTPUT
          echo "cloudfront_domain=$(terraform output -raw cloudfront_domain_name)" >> $GITHUB_OUTPUT
          echo "api_gateway_url=$(terraform output -raw api_gateway_url)" >> $GITHUB_OUTPUT
        working-directory: ./infra/terraform

      - name: Update API URL in frontend
        run: |
          # Update the API URL in the frontend JavaScript
          sed -i "s|const apiUrl = '';|const apiUrl = '${{ steps.terraform-outputs.outputs.api_gateway_url }}';|g" frontend/script.js
          
          # Create a meta tag with the API URL
          sed -i 's|<meta name="author" content="SRE/DevOps Engineer">|<meta name="author" content="SRE/DevOps Engineer">\n    <meta name="api-url" content="${{ steps.terraform-outputs.outputs.api_gateway_url }}">|g' frontend/index.html

  # Deploy application to S3
  deploy-application:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure]
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Terraform outputs
        id: terraform-outputs
        run: |
          echo "bucket_name=$(cd infra/terraform && terraform output -raw bucket_name)" >> $GITHUB_OUTPUT
          echo "cloudfront_id=$(cd infra/terraform && terraform output -raw cloudfront_distribution_id)" >> $GITHUB_OUTPUT
          echo "api_gateway_url=$(cd infra/terraform && terraform output -raw api_gateway_url)" >> $GITHUB_OUTPUT

      - name: Update frontend with API URL
        run: |
          # Update script.js with the actual API URL
          sed -i "s|this.apiUrl = '';|this.apiUrl = '${{ steps.terraform-outputs.outputs.api_gateway_url }}';|g" frontend/script.js
          
          # Add API URL as a global variable
          sed -i 's|<script src="script.js"></script>|<script>window.API_URL = "${{ steps.terraform-outputs.outputs.api_gateway_url }}";</script>\n    <script src="script.js"></script>|g' frontend/index.html

      - name: Sync files to S3
        run: |
          aws s3 sync frontend/ s3://${{ steps.terraform-outputs.outputs.bucket_name }} \
            --delete \
            --cache-control "max-age=31536000" \
            --exclude "*.html" \
            --exclude "*.css" \
            --exclude "*.js"

      - name: Sync HTML files with shorter cache
        run: |
          aws s3 sync frontend/ s3://${{ steps.terraform-outputs.outputs.bucket_name }} \
            --delete \
            --cache-control "max-age=3600" \
            --include "*.html"

      - name: Invalidate CloudFront cache
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ steps.terraform-outputs.outputs.cloudfront_id }} \
            --paths "/*"

  # Run tests and monitoring
  test-and-monitor:
    name: Test & Monitor
    runs-on: ubuntu-latest
    needs: [deploy-application]
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get CloudFront URL
        id: get-url
        run: |
          echo "url=$(cd infra/terraform && terraform output -raw cloudfront_domain_name)" >> $GITHUB_OUTPUT

      - name: Wait for deployment
        run: sleep 30

      - name: Run health checks
        run: |
          # Test main page
          curl -f https://${{ steps.get-url.outputs.url }}/
          
          # Test API endpoint
          API_URL=$(cd infra/terraform && terraform output -raw api_gateway_url)
          curl -f "$API_URL"

      - name: Run Lighthouse CI
        run: |
          npm install -g @lhci/cli
          lhci autorun --upload.target=temporary-public-storage
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}

      - name: Performance test
        run: |
          # Basic performance test
          curl -w "@curl-format.txt" -o /dev/null -s https://${{ steps.get-url.outputs.url }}/
        env:
          CURL_FORMAT: |
            time_namelookup:  %{time_namelookup}\n
            time_connect:     %{time_connect}\n
            time_appconnect:   %{time_appconnect}\n
            time_pretransfer:  %{time_pretransfer}\n
            time_redirect:     %{time_redirect}\n
            time_starttransfer: %{time_starttransfer}\n
            time_total:        %{time_total}\n

  # Notification
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [test-and-monitor]
    if: always()
    steps:
      - name: Notify success
        if: ${{ needs.test-and-monitor.result == 'success' }}
        run: |
          echo "‚úÖ Deployment successful!"
          echo "üåê Website: https://$(cd infra/terraform && terraform output -raw cloudfront_domain_name)"
          echo "üìä API: $(cd infra/terraform && terraform output -raw api_gateway_url)"

      - name: Notify failure
        if: ${{ needs.test-and-monitor.result == 'failure' }}
        run: |
          echo "‚ùå Deployment failed!"
          exit 1
